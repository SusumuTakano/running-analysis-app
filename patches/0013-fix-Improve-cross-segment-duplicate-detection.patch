From b034d9e157f51f4039fa7b8fa80f1a038e81b4c8 Mon Sep 17 00:00:00 2001
From: SusumuTakano <genspark_dev@genspark.ai>
Date: Sat, 20 Dec 2025 12:49:36 +0000
Subject: [PATCH 13/26] fix: Improve cross-segment duplicate detection
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

ğŸ› Bug: Steps 3 and 6 show abnormal stride (1.88m, 2.11m) at segment boundaries when user marks same foot contact in both segments

ğŸ” Root Cause:
Current duplicate detection only checks gap < 0.5m, but when user marks same contact twice:
- Segment 1 end: Step at 5.23m
- Segment 2 start: Same contact at 6.66m (due to different segment offset)
- Gap: 1.43m (not detected as duplicate because > 0.5m)

This causes interpolated step insertion and abnormal stride calculation.

âœ… Solution:
Enhanced duplicate detection for cross-segment boundaries:

1. Check if previous step is near segment boundary (Â±0.5m)
2. Check if current step crosses segment boundary
3. If gap < medianStride Ã— 1.5 AND crosses boundary â†’ likely duplicate
4. Skip duplicate with specific log message

Logic:
```typescript
const isNearBoundary = Math.abs(lastStepDist - prevSegmentEnd) < 0.5;
const isStepAcrossBoundary = lastStepDist < prevSegmentEnd && stepDist > prevSegmentEnd;
const isLikelyDuplicate = isNearBoundary && gap < (medianStride * 1.5);

if (isLikelyDuplicate && isStepAcrossBoundary) {
  console.log('Skipping cross-segment duplicate');
}
```

ğŸ“Š Expected Result:
- Step 3: ~1.4-1.5m (not 1.88m)
- Step 6: ~1.4-1.5m (not 2.11m)
- Cross-segment duplicates properly detected and skipped

ğŸ“ Recommended User Workflow:
**Option A (Best)**: Don't mark same contact twice - skip boundary contact in first segment
**Option B**: Mark same contact in both segments - code will auto-detect and skip duplicate

Console logs:
- 'Skipping cross-segment duplicate at Xm (boundary at Ym, gap: Zm)'

Files modified: src/App.tsx
---
 src/App.tsx | 14 +++++++++++++-
 1 file changed, 13 insertions(+), 1 deletion(-)

diff --git a/src/App.tsx b/src/App.tsx
index 281ba80..02422ac 100644
--- a/src/App.tsx
+++ b/src/App.tsx
@@ -6738,6 +6738,7 @@ const handleNewMultiCameraStart = (run: Run, segments: RunSegment[]) => {
       } else {
         // 2ã¤ç›®ä»¥é™ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆï¼šé‡è¤‡åŒºé–“ã‚’ãƒã‚§ãƒƒã‚¯
         const overlapThreshold = 0.5; // 0.5mä»¥å†…ãªã‚‰é‡è¤‡ã¨ã¿ãªã™
+        const crossSegmentThreshold = 2.0; // ã‚»ã‚°ãƒ¡ãƒ³ãƒˆå¢ƒç•Œã‚’è·¨ãã‚¹ãƒ†ãƒƒãƒ—ã®é–¾å€¤
         
         segmentSteps.forEach(step => {
           const stepDist = step.distanceAtContact || 0;
@@ -6749,10 +6750,21 @@ const handleNewMultiCameraStart = (run: Run, segments: RunSegment[]) => {
           // é‡è¤‡åˆ¤å®šã¨ã‚®ãƒ£ãƒƒãƒ—è£œé–“
           const gap = stepDist - lastStepDist;
           
+          // ğŸ¯ æ”¹å–„ã•ã‚ŒãŸé‡è¤‡æ¤œå‡ºï¼šã‚»ã‚°ãƒ¡ãƒ³ãƒˆå¢ƒç•Œä»˜è¿‘ï¼ˆå‰ã‚»ã‚°ãƒ¡ãƒ³ãƒˆçµ‚ç«¯Â±0.5mï¼‰ã®ã‚¹ãƒ†ãƒƒãƒ—ã‚’ãƒã‚§ãƒƒã‚¯
+          const prevSegmentEnd = segments[i - 1]?.endDistanceM || 0;
+          const isNearBoundary = Math.abs(lastStepDist - prevSegmentEnd) < 0.5;
+          const isStepAcrossBoundary = lastStepDist < prevSegmentEnd && stepDist > prevSegmentEnd;
+          
+          // ã‚»ã‚°ãƒ¡ãƒ³ãƒˆå¢ƒç•Œã‚’è·¨ãã‚¹ãƒ†ãƒƒãƒ—ã§ã€ã‚®ãƒ£ãƒƒãƒ—ãŒé€šå¸¸ã‚¹ãƒˆãƒ©ã‚¤ãƒ‰ã®1.5å€ä»¥å†…ãªã‚‰é‡è¤‡ã®å¯èƒ½æ€§
+          const isLikelyDuplicate = isNearBoundary && gap < (medianStride * 1.5);
+          
           if (gap < overlapThreshold) {
             // é‡è¤‡ã—ã¦ã„ã‚‹å¯èƒ½æ€§ãŒé«˜ã„ â†’ ã‚¹ã‚­ãƒƒãƒ—ï¼ˆå‰ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®ãƒ‡ãƒ¼ã‚¿ã‚’å„ªå…ˆï¼‰
             console.log(`âš ï¸ Skipping duplicate step at ${stepDist.toFixed(2)}m (gap: ${gap.toFixed(2)}m)`);
-          } else if (gap > 2.0) {
+          } else if (isLikelyDuplicate && isStepAcrossBoundary) {
+            // ğŸ†• ã‚»ã‚°ãƒ¡ãƒ³ãƒˆå¢ƒç•Œã‚’è·¨ãé‡è¤‡ã‚¹ãƒ†ãƒƒãƒ—ï¼ˆåŒã˜æ¥åœ°ã‚’ä¸¡ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã§ãƒãƒ¼ã‚¯ï¼‰
+            console.log(`âš ï¸ Skipping cross-segment duplicate at ${stepDist.toFixed(2)}m (boundary at ${prevSegmentEnd.toFixed(2)}m, gap: ${gap.toFixed(2)}m)`);
+          } else if (gap > crossSegmentThreshold) {
             // ğŸ”´ CRITICAL: ã‚®ãƒ£ãƒƒãƒ—ãŒå¤§ãã™ãã‚‹ï¼ˆ2mä»¥ä¸Šï¼‰â†’ å¢ƒç•Œã‚’è·¨ãã‚¹ãƒ†ãƒƒãƒ—ãŒæ¬ è½
             // Homographyè£œæ­£å¾Œã®ä»£è¡¨ã‚¹ãƒˆãƒ©ã‚¤ãƒ‰ï¼ˆä¸­å¤®å€¤ï¼‰ã‚’ä½¿ç”¨ã—ã¦è£œé–“
             const estimatedMissingSteps = Math.floor(gap / medianStride) - 1;
-- 
2.39.5

