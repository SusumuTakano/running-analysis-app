From a828b6df3ee38243a79a5ca8f667913b4a5448f1 Mon Sep 17 00:00:00 2001
From: SusumuTakano <genspark_dev@genspark.ai>
Date: Sat, 20 Dec 2025 12:39:06 +0000
Subject: [PATCH 12/26] fix: Exclude interpolated steps from stride
 recalculation
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

ğŸ› Bug: Segment boundary strides were abnormal (2.21m, 1.83m) due to globalDistance recalculation including interpolated steps

ğŸ” Root Cause:
Stride recalculation logic applied to ALL steps, including interpolated ones:
- Step 4: 2.21m (interpolated step included in calculation)
- Step 7: 1.83m (interpolated step included in calculation)

Interpolated steps are NOT real foot contacts, so calculating stride from their globalDistance creates artificial distances.

âœ… Solution:
1. Add 'isInterpolated' flag to StepMetric type
2. Mark interpolated steps with isInterpolated=true
3. Skip stride recalculation for:
   - Interpolated steps themselves
   - Steps immediately after interpolated steps

This preserves Homography-corrected stride values for real steps while avoiding artificial values at segment boundaries.

ğŸ“Š Expected Result:
- Step 4: ~1.4-1.5m (not 2.21m)
- Step 7: ~1.4-1.5m (not 1.83m)
- All boundary strides consistent with Homography-corrected values

Console logs:
- 'Interpolated step ... (kept as-is, not recalculated)'
- 'After interpolated step ... (kept as Homography-corrected value)'

Files modified: src/App.tsx
---
 src/App.tsx | 21 +++++++++++++++++++--
 1 file changed, 19 insertions(+), 2 deletions(-)

diff --git a/src/App.tsx b/src/App.tsx
index f159e8f..281ba80 100644
--- a/src/App.tsx
+++ b/src/App.tsx
@@ -102,6 +102,7 @@ type StepMetric = {
   // ğŸ†• è¿½åŠ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
   leg?: "left" | "right";      // ã©ã¡ã‚‰ã®è¶³ã®ã‚¹ãƒ†ãƒƒãƒ—ã‹ï¼ˆç¾æ™‚ç‚¹ã§ã¯æœªä½¿ç”¨ã§OKï¼‰
   quality?: "good" | "warning" | "bad"; // è§£æã®ä¿¡é ¼åº¦ï¼ˆè‰²åˆ†ã‘ã«ä½¿ç”¨ï¼‰
+  isInterpolated?: boolean;    // è£œé–“ã‚¹ãƒ†ãƒƒãƒ—ã‹ã©ã†ã‹ï¼ˆã‚¹ãƒˆãƒ©ã‚¤ãƒ‰å†è¨ˆç®—ã‹ã‚‰é™¤å¤–ï¼‰
   // ğŸ¯ ã‚¹ãƒ†ãƒƒãƒ—ã”ã¨ã®å§¿å‹¢ãƒ‡ãƒ¼ã‚¿ï¼ˆåŠ é€Ÿå±€é¢ã®æ®µéšçš„è©•ä¾¡ç”¨ï¼‰
   trunkAngleAtContact?: number | null;  // æ¥åœ°æ™‚ã®ä½“å¹¹è§’åº¦
   kneeFlexAtContact?: number | null;    // æ¥åœ°æ™‚ã®è†è§’åº¦ï¼ˆæ”¯æŒè„šï¼‰
@@ -6773,6 +6774,7 @@ const handleNewMultiCameraStart = (run: Run, segments: RunSegment[]) => {
                 fullStride: medianStride, // UIã§è¡¨ç¤ºã•ã‚Œã‚‹fullStrideã‚‚è¨­å®š
                 // è£œé–“ãƒ‡ãƒ¼ã‚¿ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã™ãƒ•ãƒ©ã‚°
                 quality: 'warning', // è­¦å‘Šã¨ã—ã¦è¡¨ç¤º
+                isInterpolated: true, // è£œé–“ã‚¹ãƒ†ãƒƒãƒ—ãƒ•ãƒ©ã‚°ï¼ˆã‚¹ãƒˆãƒ©ã‚¤ãƒ‰å†è¨ˆç®—ã‹ã‚‰é™¤å¤–ï¼‰
               };
               
               console.log(`   â• Interpolating step at ${interpolatedDistance.toFixed(2)}m`);
@@ -6792,8 +6794,8 @@ const handleNewMultiCameraStart = (run: Run, segments: RunSegment[]) => {
     }
     
     // ğŸ¯ ã‚°ãƒ­ãƒ¼ãƒãƒ«è·é›¢ã‹ã‚‰ã‚¹ãƒˆãƒ©ã‚¤ãƒ‰ã‚’å†è¨ˆç®—ï¼ˆChatGPTææ¡ˆï¼‰
-    // Homographyå¤‰æ›å¾Œã®globalDistanceãŒæœ€ã‚‚æ­£ç¢ºãªã®ã§ã€ã“ã‚Œã‚’åŸºæº–ã«ã‚¹ãƒˆãƒ©ã‚¤ãƒ‰ã‚’å†è¨ˆç®—
-    console.log("ğŸ”§ Recalculating strides from globalDistance (Homography-corrected world coordinates)...");
+    // ãŸã ã—ã€è£œé–“ã‚¹ãƒ†ãƒƒãƒ—ã¯é™¤å¤–ï¼ˆè£œé–“ã‚¹ãƒ†ãƒƒãƒ—ã¯å®Ÿæ¸¬å€¤ã§ã¯ãªã„ãŸã‚ï¼‰
+    console.log("ğŸ”§ Recalculating strides from globalDistance (excluding interpolated steps)...");
     
     for (let i = 0; i < finalSteps.length; i++) {
       if (i === 0) {
@@ -6802,6 +6804,21 @@ const handleNewMultiCameraStart = (run: Run, segments: RunSegment[]) => {
         continue;
       }
       
+      // ğŸš« è£œé–“ã‚¹ãƒ†ãƒƒãƒ—ã¨ã€è£œé–“ã‚¹ãƒ†ãƒƒãƒ—ã®ç›´å¾Œã®ã‚¹ãƒ†ãƒƒãƒ—ã¯ã‚¹ã‚­ãƒƒãƒ—
+      const isCurrentInterpolated = finalSteps[i].isInterpolated === true;
+      const isPrevInterpolated = finalSteps[i - 1].isInterpolated === true;
+      
+      if (isCurrentInterpolated) {
+        console.log(`  Step ${i}: Interpolated step at ${finalSteps[i].distanceAtContact?.toFixed(2)}m, stride=${finalSteps[i].stride?.toFixed(2)}m (kept as-is, not recalculated)`);
+        continue;
+      }
+      
+      if (isPrevInterpolated) {
+        console.log(`  Step ${i}: After interpolated step at ${finalSteps[i].distanceAtContact?.toFixed(2)}m, stride=${finalSteps[i].stride?.toFixed(2)}m (kept as Homography-corrected value)`);
+        continue;
+      }
+      
+      // å®Ÿæ¸¬ã‚¹ãƒ†ãƒƒãƒ—é–“ã®ã‚¹ãƒˆãƒ©ã‚¤ãƒ‰ã®ã¿å†è¨ˆç®—
       const currentDist = finalSteps[i].distanceAtContact || 0;
       const prevDist = finalSteps[i - 1].distanceAtContact || 0;
       const recalculatedStride = currentDist - prevDist;
-- 
2.39.5

