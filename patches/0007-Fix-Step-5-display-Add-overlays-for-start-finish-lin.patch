From 4f01402497ed3369f6bcd99a490c249dbc72f2e4 Mon Sep 17 00:00:00 2001
From: SusumuTakano <genspark_dev@genspark.ai>
Date: Sun, 7 Dec 2025 06:58:46 +0000
Subject: [PATCH 07/26] Fix Step 5 display - Add overlays for start/finish
 lines and skeleton

- Add drawStep5Canvas function with proper overlay rendering
- Display start line (green), finish line (red), and mid point (yellow)
- Show skeleton overlay when pose data exists
- Fix coordinate alignment by drawing everything on same canvas
- Temporarily disable manual mode (to be implemented later)
---
 src/App.tsx                           | 184 ++++++++++++----
 src/components/ManualAnalysisMode.css | 223 +++++++++++++++++++
 src/components/ManualAnalysisMode.tsx | 306 ++++++++++++++++++++++++++
 3 files changed, 673 insertions(+), 40 deletions(-)
 create mode 100644 src/components/ManualAnalysisMode.css
 create mode 100644 src/components/ManualAnalysisMode.tsx

diff --git a/src/App.tsx b/src/App.tsx
index 2668ac5..708c30d 100644
--- a/src/App.tsx
+++ b/src/App.tsx
@@ -18,6 +18,7 @@ import { CanvasRoi, getCanvasCoordinates, drawFrameWithOverlay, extractRoiForPos
 import { Step5Simple } from './components/Step5Simple';
 import { Step5Complete } from './components/Step5Complete';
 import Step5IntervalSetting, { Roi as Step5Roi } from './components/Step5IntervalSetting';
+// import { ManualAnalysisMode } from './components/ManualAnalysisMode'; // TODO: å®Ÿè£…äºˆå®š
 import { 
   Run, 
   RunSegment, 
@@ -6845,18 +6846,12 @@ const [notesInput, setNotesInput] = useState<string>("");
               <div style={{ display: 'flex', gap: '10px', flexWrap: 'wrap', justifyContent: 'center' }}>
                 <button
                   onClick={() => {
-                    // å§¿å‹¢æ¨å®šã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¦æ‰‹å‹•ãƒ¢ãƒ¼ãƒ‰ã¸
-                    console.log('å§¿å‹¢æ¨å®šã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¦æ‰‹å‹•ãƒ¢ãƒ¼ãƒ‰ã¸');
+                    // ãƒãƒ‹ãƒ¥ã‚¢ãƒ«åˆ†æãƒ¢ãƒ¼ãƒ‰ã¸åˆ‡ã‚Šæ›¿ãˆ
+                    console.log('ãƒãƒ‹ãƒ¥ã‚¢ãƒ«åˆ†æãƒ¢ãƒ¼ãƒ‰ã¸åˆ‡ã‚Šæ›¿ãˆ');
                     setIsPoseProcessing(false);
                     setPoseProgress(100);
-                    setStatus('âš ï¸ æ‰‹å‹•è¨­å®šãƒ¢ãƒ¼ãƒ‰ï¼ˆå§¿å‹¢æ¨å®šã‚’ã‚¹ã‚­ãƒƒãƒ—ï¼‰');
-                    // ç©ºã®ãƒãƒ¼ã‚ºãƒ‡ãƒ¼ã‚¿ã‚’è¨­å®š
-                    const emptyPoseResults = new Array(framesRef.current.length).fill(null);
-                    setPoseResults(emptyPoseResults);
-                    // Step 5ã¸é€²ã‚€
-                    setTimeout(() => {
-                      setWizardStep(5);
-                    }, 500);
+                    setStatus('ğŸ“¹ ãƒãƒ‹ãƒ¥ã‚¢ãƒ«åˆ†æãƒ¢ãƒ¼ãƒ‰');
+                    // setWizardStep(10); // TODO: ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ãƒ¢ãƒ¼ãƒ‰ã¯å¾Œã§å®Ÿè£…
                   }}
                   style={{
                     background: '#ef4444',
@@ -6925,6 +6920,108 @@ const [notesInput, setNotesInput] = useState<string>("");
         );
 
       case 5:
+        // Step5ç”¨ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ä»˜ãæç”»é–¢æ•°
+        const drawStep5Canvas = (frameIndex: number) => {
+          if (!displayCanvasRef.current || !framesRef.current[frameIndex]) return;
+          
+          const canvas = displayCanvasRef.current;
+          const ctx = canvas.getContext('2d');
+          if (!ctx) return;
+          
+          const frame = framesRef.current[frameIndex];
+          canvas.width = frame.width;
+          canvas.height = frame.height;
+          
+          // ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æç”»
+          ctx.putImageData(frame, 0, 0);
+          
+          // ã‚¹ã‚¿ãƒ¼ãƒˆãƒ©ã‚¤ãƒ³ï¼ˆç·‘ï¼‰ã‚’æç”»
+          if (sectionStartFrame === frameIndex) {
+            ctx.strokeStyle = '#10b981';
+            ctx.lineWidth = 3;
+            ctx.beginPath();
+            const startX = canvas.width * 0.3; // ç”»é¢ã®30%ã®ä½ç½®
+            ctx.moveTo(startX, 0);
+            ctx.lineTo(startX, canvas.height);
+            ctx.stroke();
+            
+            // ãƒ©ãƒ™ãƒ«
+            ctx.fillStyle = '#10b981';
+            ctx.font = 'bold 20px sans-serif';
+            ctx.fillText('START', startX + 10, 30);
+          }
+          
+          // ãƒ•ã‚£ãƒ‹ãƒƒã‚·ãƒ¥ãƒ©ã‚¤ãƒ³ï¼ˆèµ¤ï¼‰ã‚’æç”»
+          if (sectionEndFrame === frameIndex) {
+            ctx.strokeStyle = '#dc2626';
+            ctx.lineWidth = 3;
+            ctx.beginPath();
+            const endX = canvas.width * 0.7; // ç”»é¢ã®70%ã®ä½ç½®
+            ctx.moveTo(endX, 0);
+            ctx.lineTo(endX, canvas.height);
+            ctx.stroke();
+            
+            // ãƒ©ãƒ™ãƒ«
+            ctx.fillStyle = '#dc2626';
+            ctx.font = 'bold 20px sans-serif';
+            ctx.fillText('FINISH', endX + 10, 30);
+          }
+          
+          // ä¸­é–“ç‚¹ï¼ˆé»„è‰²ï¼‰ã‚’æç”»
+          if (sectionMidFrame === frameIndex) {
+            ctx.strokeStyle = '#fbbf24';
+            ctx.lineWidth = 2;
+            ctx.beginPath();
+            const midX = canvas.width * 0.5; // ç”»é¢ã®50%ã®ä½ç½®
+            ctx.moveTo(midX, 0);
+            ctx.lineTo(midX, canvas.height);
+            ctx.stroke();
+            
+            // ãƒ©ãƒ™ãƒ«
+            ctx.fillStyle = '#fbbf24';
+            ctx.font = 'bold 16px sans-serif';
+            ctx.fillText('MID', midX + 10, 30);
+          }
+          
+          // å§¿å‹¢ã‚¹ã‚±ãƒ«ãƒˆãƒ³ã‚’æç”»
+          const pose = poseResults[frameIndex];
+          if (pose?.landmarks) {
+            ctx.strokeStyle = '#3b82f6';
+            ctx.lineWidth = 2;
+            ctx.fillStyle = '#3b82f6';
+            
+            // MediaPipeã®æ¥ç¶šå®šç¾©
+            const connections = [
+              [11, 12], // è‚©
+              [11, 13], [13, 15], // å·¦è…•
+              [12, 14], [14, 16], // å³è…•
+              [11, 23], [12, 24], [23, 24], // èƒ´ä½“
+              [23, 25], [25, 27], [27, 29], [29, 31], // å·¦è„š
+              [24, 26], [26, 28], [28, 30], [30, 32], // å³è„š
+            ];
+            
+            // éª¨æ ¼ç·šã‚’æç”»
+            connections.forEach(([start, end]) => {
+              const p1 = pose.landmarks[start];
+              const p2 = pose.landmarks[end];
+              if (p1 && p2 && p1.visibility > 0.001 && p2.visibility > 0.001) {
+                ctx.beginPath();
+                ctx.moveTo(p1.x * canvas.width, p1.y * canvas.height);
+                ctx.lineTo(p2.x * canvas.width, p2.y * canvas.height);
+                ctx.stroke();
+              }
+            });
+            
+            // é–¢ç¯€ç‚¹ã‚’æç”»
+            pose.landmarks.forEach((lm, idx) => {
+              if (lm && lm.visibility > 0.001) {
+                ctx.beginPath();
+                ctx.arc(lm.x * canvas.width, lm.y * canvas.height, 4, 0, Math.PI * 2);
+                ctx.fill();
+              }
+            });
+          }
+        };
 
         // ãƒãƒ«ãƒã‚«ãƒ¡ãƒ©ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã¯åŒºé–“è¨­å®šã‚’ã‚¹ã‚­ãƒƒãƒ—
         if (analysisMode === "multi") {
@@ -6982,16 +7079,7 @@ const [notesInput, setNotesInput] = useState<string>("");
         
         // åˆå›è¡¨ç¤ºæ™‚ã«ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æç”»
         setTimeout(() => {
-          if (displayCanvasRef.current && framesRef.current[currentFrame]) {
-            const canvas = displayCanvasRef.current;
-            const ctx = canvas.getContext('2d');
-            if (ctx) {
-              const frame = framesRef.current[currentFrame];
-              canvas.width = frame.width;
-              canvas.height = frame.height;
-              ctx.putImageData(frame, 0, 0);
-            }
-          }
+          drawStep5Canvas(currentFrame);
         }, 100);
         
         // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã«ã‚ˆã‚‹åŒºé–“è¨­å®šUIï¼ˆãƒˆãƒªãƒŸãƒ³ã‚°æ©Ÿèƒ½æ™‚ä»£ã®ã‚·ãƒ³ãƒ—ãƒ«æ–¹å¼ã«æˆ»ã™ï¼‰
@@ -7104,16 +7192,7 @@ const [notesInput, setNotesInput] = useState<string>("");
                     setStartLineOffset(0);
                     
                     // ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’è¡¨ç¤º
-                    if (displayCanvasRef.current && framesRef.current[newFrame]) {
-                      const canvas = displayCanvasRef.current;
-                      const ctx = canvas.getContext('2d');
-                      if (ctx) {
-                        const frame = framesRef.current[newFrame];
-                        canvas.width = frame.width;
-                        canvas.height = frame.height;
-                        ctx.putImageData(frame, 0, 0);
-                      }
-                    }
+                    drawStep5Canvas(newFrame);
                   }}
                   className="section-slider start-slider"
                 />
@@ -7250,16 +7329,7 @@ const [notesInput, setNotesInput] = useState<string>("");
                     setEndLineOffset(0);
                     
                     // ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’è¡¨ç¤º
-                    if (displayCanvasRef.current && framesRef.current[newFrame]) {
-                      const canvas = displayCanvasRef.current;
-                      const ctx = canvas.getContext('2d');
-                      if (ctx) {
-                        const frame = framesRef.current[newFrame];
-                        canvas.width = frame.width;
-                        canvas.height = frame.height;
-                        ctx.putImageData(frame, 0, 0);
-                      }
-                    }
+                    drawStep5Canvas(newFrame);
                   }}
                   className="section-slider end-slider"
                 />
@@ -9928,6 +9998,40 @@ const [notesInput, setNotesInput] = useState<string>("");
           </div>
         );
 
+      /* case 10: // ãƒãƒ‹ãƒ¥ã‚¢ãƒ«åˆ†æãƒ¢ãƒ¼ãƒ‰ - TODO: å®Ÿè£…äºˆå®š
+        return (
+          <ManualAnalysisMode
+            videoUrl={videoUrl || ''}
+            frames={framesRef.current}
+            fps={selectedFps}
+            onAnalysisComplete={(data) => {
+              console.log('Manual analysis complete:', data);
+              // åˆ†æçµæœã‚’ä¿å­˜
+              setManualContactFrames(data.contactFrames);
+              setSectionStartFrame(data.startFrame);
+              setSectionEndFrame(data.endFrame);
+              
+              // ã‚¹ãƒ†ãƒƒãƒ—ã‚’è¨ˆç®—
+              const steps = data.strides.map((stride: any, index: number) => ({
+                stepNumber: index + 1,
+                footContact: data.contactFrames[index],
+                toeOff: data.contactFrames[index] + Math.floor(stride.frames / 2),
+                contactTime: stride.time / 2,
+                flightTime: stride.time / 2,
+                strideTime: stride.time,
+                sectionStride: stride.length,
+                speed: data.speed,
+                avgHipX: 0.5,
+                contactToeY: 0.8,
+                liftOffToeY: 0.8
+              }));
+              
+              setSteps(steps);
+              setWizardStep(8); // çµæœè¡¨ç¤ºã¸
+            }}
+          />
+        ); */
+
       default:
         return null;
     }
diff --git a/src/components/ManualAnalysisMode.css b/src/components/ManualAnalysisMode.css
new file mode 100644
index 0000000..e359d49
--- /dev/null
+++ b/src/components/ManualAnalysisMode.css
@@ -0,0 +1,223 @@
+.manual-analysis-mode {
+  max-width: 1200px;
+  margin: 0 auto;
+  padding: 20px;
+}
+
+.header {
+  text-align: center;
+  margin-bottom: 20px;
+}
+
+.header h2 {
+  font-size: 24px;
+  font-weight: bold;
+  color: #333;
+  margin-bottom: 10px;
+}
+
+.header p {
+  color: #666;
+  font-size: 14px;
+}
+
+.canvas-container {
+  position: relative;
+  margin-bottom: 20px;
+  border: 2px solid #ddd;
+  border-radius: 8px;
+  overflow: hidden;
+  background: #f0f0f0;
+}
+
+.analysis-canvas {
+  width: 100%;
+  height: auto;
+  display: block;
+  cursor: crosshair;
+}
+
+.frame-info {
+  position: absolute;
+  top: 10px;
+  right: 10px;
+  background: rgba(0,0,0,0.7);
+  color: white;
+  padding: 5px 10px;
+  border-radius: 4px;
+  font-size: 12px;
+}
+
+.controls {
+  background: #f9f9f9;
+  padding: 20px;
+  border-radius: 8px;
+  margin-bottom: 20px;
+}
+
+.playback-controls {
+  display: flex;
+  justify-content: center;
+  gap: 10px;
+  margin-bottom: 15px;
+}
+
+.playback-controls button {
+  padding: 8px 15px;
+  background: #007bff;
+  color: white;
+  border: none;
+  border-radius: 4px;
+  cursor: pointer;
+  font-size: 14px;
+}
+
+.playback-controls button:hover {
+  background: #0056b3;
+}
+
+.speed-control {
+  text-align: center;
+  margin-bottom: 15px;
+}
+
+.speed-control label {
+  margin-right: 10px;
+  font-weight: bold;
+}
+
+.speed-control select {
+  padding: 5px 10px;
+  border-radius: 4px;
+  border: 1px solid #ddd;
+}
+
+.frame-slider {
+  margin-top: 15px;
+}
+
+.slider {
+  width: 100%;
+  height: 6px;
+}
+
+.marking-instructions {
+  background: #fff3cd;
+  padding: 20px;
+  border-radius: 8px;
+  border: 2px solid #ffc107;
+  margin-bottom: 20px;
+}
+
+.marking-instructions h3 {
+  margin-top: 0;
+  color: #856404;
+}
+
+.marking-instructions ol {
+  margin: 10px 0;
+  padding-left: 25px;
+}
+
+.marking-instructions li {
+  margin: 8px 0;
+  color: #856404;
+}
+
+.marking-instructions li.active {
+  font-weight: bold;
+  color: #d39e00;
+  font-size: 1.1em;
+}
+
+.marking-instructions li.done {
+  color: #28a745;
+  text-decoration: line-through;
+}
+
+.distance-input {
+  background: #e7f3ff;
+  padding: 15px;
+  border-radius: 8px;
+  margin-bottom: 20px;
+  text-align: center;
+}
+
+.distance-input label {
+  margin-right: 10px;
+  font-weight: bold;
+}
+
+.distance-input input {
+  width: 100px;
+  padding: 5px;
+  font-size: 16px;
+  text-align: center;
+  border: 1px solid #007bff;
+  border-radius: 4px;
+}
+
+.marker-list {
+  background: #f0f8ff;
+  padding: 15px;
+  border-radius: 8px;
+  margin-bottom: 20px;
+}
+
+.marker-list h3 {
+  margin-top: 0;
+  color: #0066cc;
+}
+
+.marker-summary {
+  display: flex;
+  gap: 20px;
+  flex-wrap: wrap;
+}
+
+.marker-summary > div {
+  padding: 8px 15px;
+  background: white;
+  border-radius: 6px;
+  border: 1px solid #ddd;
+}
+
+.action-buttons {
+  display: flex;
+  justify-content: center;
+  gap: 20px;
+  margin-top: 30px;
+}
+
+.btn-reset, .btn-analyze {
+  padding: 12px 30px;
+  font-size: 16px;
+  font-weight: bold;
+  border: none;
+  border-radius: 6px;
+  cursor: pointer;
+  transition: all 0.3s;
+}
+
+.btn-reset {
+  background: #6c757d;
+  color: white;
+}
+
+.btn-reset:hover {
+  background: #545b62;
+}
+
+.btn-analyze {
+  background: #28a745;
+  color: white;
+}
+
+.btn-analyze:hover {
+  background: #218838;
+}
+
+.btn-analyze:disabled {
+  background: #ccc;
+  cursor: not-allowed;
+}
\ No newline at end of file
diff --git a/src/components/ManualAnalysisMode.tsx b/src/components/ManualAnalysisMode.tsx
new file mode 100644
index 0000000..4c5bf81
--- /dev/null
+++ b/src/components/ManualAnalysisMode.tsx
@@ -0,0 +1,306 @@
+import React, { useState, useRef, useEffect } from 'react';
+import './ManualAnalysisMode.css';
+
+interface ManualAnalysisModeProps {
+  videoUrl: string;
+  frames: ImageData[];
+  fps: number;
+  onAnalysisComplete: (data: any) => void;
+}
+
+export const ManualAnalysisMode: React.FC<ManualAnalysisModeProps> = ({
+  videoUrl,
+  frames,
+  fps,
+  onAnalysisComplete
+}) => {
+  const canvasRef = useRef<HTMLCanvasElement>(null);
+  const [currentFrame, setCurrentFrame] = useState(0);
+  const [isPlaying, setIsPlaying] = useState(false);
+  const [playbackSpeed, setPlaybackSpeed] = useState(0.25); // 0.25å€é€Ÿ
+  const [markers, setMarkers] = useState<{frame: number, x: number, y: number, type: 'start' | 'end' | 'contact'}[]>([]);
+  const [startMarker, setStartMarker] = useState<number | null>(null);
+  const [endMarker, setEndMarker] = useState<number | null>(null);
+  const [contactMarkers, setContactMarkers] = useState<number[]>([]);
+  const [distance, setDistance] = useState<number>(10);
+  const animationRef = useRef<number>();
+
+  // ãƒ•ãƒ¬ãƒ¼ãƒ æç”»
+  const drawFrame = (frameIndex: number) => {
+    const canvas = canvasRef.current;
+    if (!canvas || !frames[frameIndex]) return;
+
+    const ctx = canvas.getContext('2d');
+    if (!ctx) return;
+
+    canvas.width = frames[frameIndex].width;
+    canvas.height = frames[frameIndex].height;
+    ctx.putImageData(frames[frameIndex], 0, 0);
+
+    // ãƒãƒ¼ã‚«ãƒ¼ã‚’æç”»
+    markers.forEach(marker => {
+      if (marker.frame === frameIndex) {
+        ctx.strokeStyle = marker.type === 'start' ? '#00ff00' : 
+                         marker.type === 'end' ? '#ff0000' : '#ffff00';
+        ctx.lineWidth = 3;
+        ctx.beginPath();
+        ctx.arc(marker.x * canvas.width, marker.y * canvas.height, 10, 0, 2 * Math.PI);
+        ctx.stroke();
+        
+        // ãƒ©ãƒ™ãƒ«
+        ctx.fillStyle = ctx.strokeStyle;
+        ctx.font = 'bold 16px Arial';
+        ctx.fillText(
+          marker.type === 'start' ? 'START' : 
+          marker.type === 'end' ? 'END' : 
+          `æ¥åœ°${contactMarkers.indexOf(marker.frame) + 1}`,
+          marker.x * canvas.width + 15, 
+          marker.y * canvas.height - 5
+        );
+      }
+    });
+
+    // ã‚¹ã‚¿ãƒ¼ãƒˆãƒ©ã‚¤ãƒ³
+    if (startMarker === frameIndex) {
+      ctx.strokeStyle = '#00ff00';
+      ctx.lineWidth = 3;
+      ctx.beginPath();
+      ctx.moveTo(0, canvas.height * 0.7);
+      ctx.lineTo(canvas.width, canvas.height * 0.7);
+      ctx.stroke();
+    }
+
+    // ã‚¨ãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³
+    if (endMarker === frameIndex) {
+      ctx.strokeStyle = '#ff0000';
+      ctx.lineWidth = 3;
+      ctx.beginPath();
+      ctx.moveTo(0, canvas.height * 0.7);
+      ctx.lineTo(canvas.width, canvas.height * 0.7);
+      ctx.stroke();
+    }
+  };
+
+  // å†ç”Ÿå‡¦ç†
+  useEffect(() => {
+    if (isPlaying) {
+      const frameInterval = 1000 / (fps * playbackSpeed);
+      
+      const animate = () => {
+        setCurrentFrame(prev => {
+          const next = prev + 1;
+          if (next >= frames.length) {
+            setIsPlaying(false);
+            return prev;
+          }
+          return next;
+        });
+        animationRef.current = setTimeout(animate, frameInterval);
+      };
+      
+      animationRef.current = setTimeout(animate, frameInterval);
+    } else {
+      if (animationRef.current) {
+        clearTimeout(animationRef.current);
+      }
+    }
+
+    return () => {
+      if (animationRef.current) {
+        clearTimeout(animationRef.current);
+      }
+    };
+  }, [isPlaying, fps, playbackSpeed, frames.length]);
+
+  // ãƒ•ãƒ¬ãƒ¼ãƒ å¤‰æ›´æ™‚ã®æç”»
+  useEffect(() => {
+    drawFrame(currentFrame);
+  }, [currentFrame, markers]);
+
+  // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚¯ãƒªãƒƒã‚¯å‡¦ç†
+  const handleCanvasClick = (e: React.MouseEvent) => {
+    const canvas = canvasRef.current;
+    if (!canvas) return;
+
+    const rect = canvas.getBoundingClientRect();
+    const x = (e.clientX - rect.left) / rect.width;
+    const y = (e.clientY - rect.top) / rect.height;
+
+    // ç¾åœ¨ã®ãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ã¦ãƒãƒ¼ã‚«ãƒ¼ã‚’è¿½åŠ 
+    const markerType = startMarker === null ? 'start' : 
+                      endMarker === null ? 'end' : 'contact';
+
+    const newMarker = { frame: currentFrame, x, y, type: markerType as any };
+    setMarkers([...markers, newMarker]);
+
+    if (markerType === 'start') {
+      setStartMarker(currentFrame);
+    } else if (markerType === 'end') {
+      setEndMarker(currentFrame);
+    } else {
+      setContactMarkers([...contactMarkers, currentFrame].sort((a, b) => a - b));
+    }
+  };
+
+  // åˆ†æå®Ÿè¡Œ
+  const runAnalysis = () => {
+    if (startMarker === null || endMarker === null || contactMarkers.length < 2) {
+      alert('ã‚¹ã‚¿ãƒ¼ãƒˆåœ°ç‚¹ã€ã‚´ãƒ¼ãƒ«åœ°ç‚¹ã€æœ€ä½2ã¤ã®æ¥åœ°ç‚¹ã‚’è¨­å®šã—ã¦ãã ã•ã„');
+      return;
+    }
+
+    // ãƒ•ãƒ¬ãƒ¼ãƒ å·®ã‹ã‚‰æ™‚é–“ã‚’è¨ˆç®—
+    const totalFrames = endMarker - startMarker;
+    const totalTime = totalFrames / fps;
+
+    // ã‚¹ãƒˆãƒ©ã‚¤ãƒ‰ã‚’è¨ˆç®—
+    const strides = [];
+    for (let i = 0; i < contactMarkers.length - 1; i++) {
+      const frameDistance = contactMarkers[i + 1] - contactMarkers[i];
+      const strideRatio = frameDistance / totalFrames;
+      const strideLength = distance * strideRatio;
+      strides.push({
+        step: i + 1,
+        length: strideLength,
+        frames: frameDistance,
+        time: frameDistance / fps
+      });
+    }
+
+    const avgStride = strides.reduce((sum, s) => sum + s.length, 0) / strides.length;
+    const speed = distance / totalTime;
+
+    const analysisData = {
+      distance,
+      totalTime,
+      speed,
+      avgStride,
+      strides,
+      contactFrames: contactMarkers,
+      startFrame: startMarker,
+      endFrame: endMarker
+    };
+
+    console.log('Analysis complete:', analysisData);
+    onAnalysisComplete(analysisData);
+  };
+
+  return (
+    <div className="manual-analysis-mode">
+      <div className="header">
+        <h2>ğŸ“¹ ã‚»ãƒŸãƒãƒ‹ãƒ¥ã‚¢ãƒ«åˆ†æãƒ¢ãƒ¼ãƒ‰</h2>
+        <p>AIãŒæ¤œå‡ºã§ããªã„å ´åˆã®ä»£æ›¿åˆ†ææ–¹æ³•</p>
+      </div>
+
+      <div className="canvas-container">
+        <canvas
+          ref={canvasRef}
+          onClick={handleCanvasClick}
+          className="analysis-canvas"
+        />
+        <div className="frame-info">
+          ãƒ•ãƒ¬ãƒ¼ãƒ : {currentFrame} / {frames.length - 1} 
+          ï¼ˆ{(currentFrame / fps).toFixed(2)}ç§’ï¼‰
+        </div>
+      </div>
+
+      <div className="controls">
+        <div className="playback-controls">
+          <button onClick={() => setCurrentFrame(Math.max(0, currentFrame - 10))}>
+            âª -10
+          </button>
+          <button onClick={() => setCurrentFrame(Math.max(0, currentFrame - 1))}>
+            â® -1
+          </button>
+          <button onClick={() => setIsPlaying(!isPlaying)}>
+            {isPlaying ? 'â¸ ä¸€æ™‚åœæ­¢' : 'â–¶ï¸ å†ç”Ÿ'}
+          </button>
+          <button onClick={() => setCurrentFrame(Math.min(frames.length - 1, currentFrame + 1))}>
+            â­ +1
+          </button>
+          <button onClick={() => setCurrentFrame(Math.min(frames.length - 1, currentFrame + 10))}>
+            â© +10
+          </button>
+        </div>
+
+        <div className="speed-control">
+          <label>å†ç”Ÿé€Ÿåº¦:</label>
+          <select value={playbackSpeed} onChange={(e) => setPlaybackSpeed(Number(e.target.value))}>
+            <option value={0.1}>0.1x</option>
+            <option value={0.25}>0.25x</option>
+            <option value={0.5}>0.5x</option>
+            <option value={1}>1x</option>
+          </select>
+        </div>
+
+        <div className="frame-slider">
+          <input
+            type="range"
+            min={0}
+            max={frames.length - 1}
+            value={currentFrame}
+            onChange={(e) => setCurrentFrame(Number(e.target.value))}
+            className="slider"
+          />
+        </div>
+      </div>
+
+      <div className="marking-instructions">
+        <h3>ğŸ“ ãƒãƒ¼ã‚­ãƒ³ã‚°æ‰‹é †</h3>
+        <ol>
+          <li className={startMarker === null ? 'active' : 'done'}>
+            {startMarker === null ? 'ğŸ‘‰' : 'âœ…'} ã‚¹ã‚¿ãƒ¼ãƒˆåœ°ç‚¹ã§ã‚¯ãƒªãƒƒã‚¯ï¼ˆç·‘ï¼‰
+          </li>
+          <li className={endMarker === null ? (startMarker !== null ? 'active' : '') : 'done'}>
+            {endMarker === null ? 'ğŸ‘‰' : 'âœ…'} ã‚´ãƒ¼ãƒ«åœ°ç‚¹ã§ã‚¯ãƒªãƒƒã‚¯ï¼ˆèµ¤ï¼‰
+          </li>
+          <li className={startMarker !== null && endMarker !== null ? 'active' : ''}>
+            ğŸ‘‰ å„æ¥åœ°ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ã‚¯ãƒªãƒƒã‚¯ï¼ˆé»„ï¼‰ - ç¾åœ¨: {contactMarkers.length}å€‹
+          </li>
+        </ol>
+      </div>
+
+      <div className="distance-input">
+        <label>å®Ÿæ¸¬è·é›¢ï¼ˆãƒ¡ãƒ¼ãƒˆãƒ«ï¼‰:</label>
+        <input
+          type="number"
+          value={distance}
+          onChange={(e) => setDistance(Number(e.target.value))}
+          min={1}
+          max={100}
+        />
+      </div>
+
+      <div className="marker-list">
+        <h3>ğŸ“Œ è¨­å®šã•ã‚ŒãŸãƒãƒ¼ã‚«ãƒ¼</h3>
+        <div className="marker-summary">
+          <div>ğŸŸ¢ ã‚¹ã‚¿ãƒ¼ãƒˆ: {startMarker !== null ? `ãƒ•ãƒ¬ãƒ¼ãƒ  ${startMarker}` : 'æœªè¨­å®š'}</div>
+          <div>ğŸ”´ ã‚´ãƒ¼ãƒ«: {endMarker !== null ? `ãƒ•ãƒ¬ãƒ¼ãƒ  ${endMarker}` : 'æœªè¨­å®š'}</div>
+          <div>ğŸŸ¡ æ¥åœ°ç‚¹: {contactMarkers.length}å€‹</div>
+        </div>
+      </div>
+
+      <div className="action-buttons">
+        <button 
+          onClick={() => {
+            setMarkers([]);
+            setStartMarker(null);
+            setEndMarker(null);
+            setContactMarkers([]);
+          }}
+          className="btn-reset"
+        >
+          ğŸ”„ ãƒªã‚»ãƒƒãƒˆ
+        </button>
+        
+        <button 
+          onClick={runAnalysis}
+          className="btn-analyze"
+          disabled={startMarker === null || endMarker === null || contactMarkers.length < 2}
+        >
+          ğŸ“Š åˆ†æå®Ÿè¡Œ
+        </button>
+      </div>
+    </div>
+  );
+};
\ No newline at end of file
-- 
2.39.5

