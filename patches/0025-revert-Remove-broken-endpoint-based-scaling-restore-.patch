From a51303104db7e7d252be415fea15abd1744e5fb5 Mon Sep 17 00:00:00 2001
From: SusumuTakano <genspark_dev@genspark.ai>
Date: Sat, 20 Dec 2025 22:43:07 +0000
Subject: [PATCH 25/26] revert: Remove broken endpoint-based scaling, restore
 original Homography

The endpoint-based scaling approach (98615bb) completely failed:
- Lost most steps (only 1 step remained out of 4 in segment 1)
- Created abnormal stride values (2.39m, 5.00m)
- Caused per-segment validation failures

Root Issue with Scaling Approach:
- Scaling factor calculation used first/last steps only
- This doesn't account for all intermediate steps
- When applied, many steps disappeared during processing
- Example: Segment 1 had 4 steps (frames 17,54,92,128) but only 3 survived merging

Decision: Revert to Original Homography
- Accept the 10cm stride discrepancy as Homography limitation
- Original approach at least preserves all steps correctly
- User can improve accuracy by better cone placement during calibration

The fundamental issue is that perfect calibration is nearly impossible:
- Physical cone placement has inherent ~0.2-0.5m variance
- Software scaling introduces other artifacts and step loss
- Best approach: Improve calibration UI instructions (already done)
---
 src/App.tsx | 62 +++++++++++++----------------------------------------
 1 file changed, 15 insertions(+), 47 deletions(-)

diff --git a/src/App.tsx b/src/App.tsx
index d8e8e1c..bffcc82 100644
--- a/src/App.tsx
+++ b/src/App.tsx
@@ -6659,32 +6659,6 @@ const handleNewMultiCameraStart = (run: Run, segments: RunSegment[]) => {
         }
       };
       
-      // ğŸ”§ STEP 1: ã¾ãšHomographyå¤‰æ›ã§å…¨ã‚¹ãƒ†ãƒƒãƒ—ã® rawWorldY ã‚’å–å¾—
-      const rawWorldYValues: Array<{ stepIdx: number; worldY: number }> = [];
-      segmentSteps.forEach((step, localIdx) => {
-        if (step.contactPixelX != null && step.contactPixelY != null) {
-          const worldPos = applyHomographyLocal(step.contactPixelX, step.contactPixelY);
-          if (worldPos) {
-            rawWorldYValues.push({ stepIdx: localIdx, worldY: worldPos.y });
-          }
-        }
-      });
-      
-      // ğŸ”§ STEP 2: ç«¯ç‚¹ãƒ™ãƒ¼ã‚¹æ¯”ä¾‹ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°ä¿‚æ•°ã‚’è¨ˆç®—ï¼ˆã‚·ãƒ³ã‚°ãƒ«ã‚«ãƒ¡ãƒ©ã¨åŒã˜ã‚¢ãƒ—ãƒ­ãƒ¼ãƒï¼‰
-      let scalingFactor = 1.0;
-      if (rawWorldYValues.length >= 2) {
-        const firstWorldY = rawWorldYValues[0].worldY;
-        const lastWorldY = rawWorldYValues[rawWorldYValues.length - 1].worldY;
-        const actualRange = Math.abs(lastWorldY - firstWorldY); // Homographyå®Ÿæ¸¬ç¯„å›²
-        const expectedRange = segment.endDistanceM - segment.startDistanceM; // æœŸå¾…ã•ã‚Œã‚‹ç¯„å›²ï¼ˆ5mï¼‰
-        
-        if (actualRange > 0.1) {
-          scalingFactor = expectedRange / actualRange;
-          console.log(`  ğŸ“ Endpoint-based scaling: actualRange=${actualRange.toFixed(2)}m (${firstWorldY.toFixed(2)}-${lastWorldY.toFixed(2)}m), expected=${expectedRange.toFixed(2)}m, factor=${scalingFactor.toFixed(4)}`);
-        }
-      }
-      
-      // ğŸ”§ STEP 3: ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°ã‚’é©ç”¨ã—ã¦ã‚¹ãƒ†ãƒƒãƒ—ã‚’å‡¦ç†
       segmentSteps.forEach((step, localIdx) => {
         let localDistance = step.distanceAtContact || 0;
         let recalculatedStride = step.stride;
@@ -6693,35 +6667,29 @@ const handleNewMultiCameraStart = (run: Run, segments: RunSegment[]) => {
         if (step.contactPixelX != null && step.contactPixelY != null) {
           const worldPos = applyHomographyLocal(step.contactPixelX, step.contactPixelY);
           
-          if (worldPos && rawWorldYValues.length >= 2) {
-            const firstWorldY = rawWorldYValues[0].worldY;
-            
-            // âœ… ç«¯ç‚¹ãƒ™ãƒ¼ã‚¹ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°é©ç”¨ï¼ˆã‚·ãƒ³ã‚°ãƒ«ã‚«ãƒ¡ãƒ©ã¨åŒã˜è€ƒãˆæ–¹ï¼‰
-            // æœ€åˆã®ã‚¹ãƒ†ãƒƒãƒ—ã‚’0mã¨ã—ã¦ã€ãã“ã‹ã‚‰ã®ç›¸å¯¾è·é›¢ã‚’ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°
-            const relativeDistance = Math.abs(worldPos.y - firstWorldY);
-            localDistance = relativeDistance * scalingFactor;
+          if (worldPos) {
+            // å®Ÿä¸–ç•Œåº§æ¨™ã®Yæˆåˆ†ã‚’è·é›¢ã¨ã—ã¦ä½¿ç”¨ï¼ˆèµ°è¡Œæ–¹å‘ï¼yè»¸ï¼‰
+            // Xæˆåˆ†ã¯ãƒ¬ãƒ¼ãƒ³å¹…æ–¹å‘ï¼ˆ0ã€œ1.22mï¼‰ã€Yæˆåˆ†ã¯èµ°è¡Œæ–¹å‘ï¼ˆ0ã€œ15mï¼‰
+            localDistance = Math.abs(worldPos.y - segment.startDistanceM);
             
-            console.log(`  ğŸ¯ Step ${localIdx}: Pixel(${step.contactPixelX.toFixed(0)}, ${step.contactPixelY.toFixed(0)}) â†’ World(y=${worldPos.y.toFixed(2)}m) â†’ Scaled: ${localDistance.toFixed(2)}m (factor=${scalingFactor.toFixed(3)})`);
+            console.log(`  ğŸ¯ Step ${localIdx}: Pixel(${step.contactPixelX.toFixed(0)}, ${step.contactPixelY.toFixed(0)}) â†’ World(${worldPos.x.toFixed(2)}, ${worldPos.y.toFixed(2)})m (x=lane, y=distance) â†’ localDistance=${localDistance.toFixed(2)}m`);
             
-            // æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ã®ãƒ”ã‚¯ã‚»ãƒ«åº§æ¨™ãŒã‚ã‚Œã°ã€ã‚¹ãƒˆãƒ©ã‚¤ãƒ‰ã‚‚å†è¨ˆç®—ï¼ˆã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°é©ç”¨å¾Œï¼‰
+            // æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ã®ãƒ”ã‚¯ã‚»ãƒ«åº§æ¨™ãŒã‚ã‚Œã°ã€ã‚¹ãƒˆãƒ©ã‚¤ãƒ‰ã‚‚å†è¨ˆç®—
             const nextStep = segmentSteps[localIdx + 1];
             if (nextStep?.contactPixelX != null && nextStep?.contactPixelY != null) {
               const nextWorldPos = applyHomographyLocal(nextStep.contactPixelX, nextStep.contactPixelY);
               if (nextWorldPos) {
-                // ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°é©ç”¨å¾Œã®è·é›¢
-                const nextRelativeDistance = Math.abs(nextWorldPos.y - firstWorldY);
-                const nextLocalDistance = nextRelativeDistance * scalingFactor;
-                
-                // ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°æ¸ˆã¿ã‚¹ãƒˆãƒ©ã‚¤ãƒ‰è¨ˆç®—
-                const scaledDy = nextLocalDistance - localDistance;
-                const dx = nextWorldPos.x - worldPos.x; // ãƒ¬ãƒ¼ãƒ³å¹…æ–¹å‘ã¯ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°ä¸è¦
-                recalculatedStride = Math.sqrt(dx * dx + scaledDy * scaledDy);
+                // å®Ÿä¸–ç•Œåº§æ¨™ã§ã®ã‚¹ãƒˆãƒ©ã‚¤ãƒ‰ã‚’è¨ˆç®—ï¼ˆãƒ¦ãƒ¼ã‚¯ãƒªãƒƒãƒ‰è·é›¢ï¼‰
+                // dx = ãƒ¬ãƒ¼ãƒ³å¹…æ–¹å‘ã®ç§»å‹•, dy = èµ°è¡Œæ–¹å‘ã®ç§»å‹•
+                const dx = nextWorldPos.x - worldPos.x;
+                const dy = nextWorldPos.y - worldPos.y;
+                recalculatedStride = Math.sqrt(dx * dx + dy * dy);
                 
-                console.log(`    âœ… Scaled stride: ${recalculatedStride.toFixed(2)}m (dy_scaled=${scaledDy.toFixed(2)}, dx=${dx.toFixed(2)})`);
+                console.log(`    âœ… Recalculated stride using Homography: ${recalculatedStride.toFixed(2)}m (dx=${dx.toFixed(2)}, dy=${dy.toFixed(2)}) (was ${step.stride?.toFixed(2) ?? 'N/A'}m)`);
               }
             }
           } else {
-            console.warn(`  âš ï¸ Step ${localIdx}: Homography failed or insufficient data for scaling`);
+            console.warn(`  âš ï¸ Step ${localIdx}: Homography failed, using fallback distance`);
           }
         } else {
           console.warn(`  âš ï¸ Step ${localIdx}: No pixel coordinates, using fallback distance`);
@@ -6733,8 +6701,8 @@ const handleNewMultiCameraStart = (run: Run, segments: RunSegment[]) => {
         
         mergedSteps.push({
           ...step,
-          stride: recalculatedStride, // TrueStride: ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°é©ç”¨å¾Œ
-          fullStride: recalculatedStride ?? undefined,
+          stride: recalculatedStride, // TrueStride: Homographyã§å†è¨ˆç®—ã•ã‚ŒãŸã‚¹ãƒˆãƒ©ã‚¤ãƒ‰
+          fullStride: recalculatedStride ?? undefined, // UIã§è¡¨ç¤ºã•ã‚Œã‚‹fullStrideã‚‚æ›´æ–°
           distanceAtContact: globalDistance,
           index: globalStepIndex++,
           segmentId: segment.id,
-- 
2.39.5

